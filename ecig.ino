// screen stuff
#include <U8glib.h>
U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE); // screen object
#define SCREENWIDTH 128 // 22mm wide
#define SCREENHEIGHT 64 // 11mm tall
#define FONT u8g_font_courB14
#define LINEFIRST   5   // dependent on font used
#define LINEHEIGHT 16
#define LEFTEDGE    4
#define RIGHTEDGE 124   // used if text should be rotated 180deg
char line1[15];
char line2[15];
char line3[15];


#include <TimerOne.h>

// pin definitions
#define PIN_BOARDLED    13
#define PIN_READVOLTAGE A1
#define PIN_PUSHBUTTON   2
#define PIN_WATTSINC     7
#define PIN_WATTSDEC     6
#define PIN_COIL_PWM     9 // default of timer1 Fast PWM mode
//#define PIN_HR_MONITOR  A2
#define PIN_HR_MONITOR  A0

// SDA A4 (Wire.h included by U8glib.h)
// SCL A5 (Wire.h included by U8glib.h)

// EEPROM locations

// magic numbers
const uint16_t COILmOHMS = 2100;   // coil is 2.1 ohm
const uint16_t MAXWATTAGE = 17000; // maximum coil wattage (about 6V at 2.1 ohm)
const uint16_t MINWATTAGE = 3000;  // minimum coil wattage
const uint16_t MAXmV = 7400;       // battery max cutoff (for 100% capacity; excess returns 100% still)
const uint16_t MINmV = 7100;       // battery getting low
const uint16_t CHARGEmV = 8100;    // minimum mV to be considered charging (charge at 8.4V)
const uint8_t VDIV = 89;           // voltage divider (7.4V between 2x 10M on a 5Vmax mapped 0-1023)
const uint8_t MINHR = 50;          // minimum heart rate to display/interrupt with
const uint8_t DEBOUNCEWAITMS = 40; // ms to lock during debounce for

// continuous variables
volatile uint16_t MW = (MAXWATTAGE + MINWATTAGE) / 2; // initialize in the middle of range
volatile uint16_t MW_former = MW;
volatile uint32_t currentmv = 7400; // larger to deal with overflow
volatile uint32_t debouncelock = 0; // contains millis()
bool pwmlock = false;

// BPM values
volatile uint8_t heart_BPM = 0;           // used to hold the pulse rate
volatile uint16_t Signal;                 // holds the incoming raw data
volatile int IBI = 600;                   // holds the time between beats, the Inter-Beat Interval
volatile boolean Pulse = false;           // true when pulse wave is high, false when it's low
volatile boolean QS = false;              // becomes true when Arduoino finds a beat.

volatile int rate[10];                    // last ten IBI values
volatile unsigned long sampleCounter = 0; // determine pulse timing (count up in ms)
volatile unsigned long lastBeatTime = 0;  // inter beat interval
volatile uint16_t peak = 512;             // peak in pulse wave
volatile uint16_t trough = 512;           // trough in pulse wave
volatile uint16_t thresh = 512;           // instant moment of heart beat
volatile int amp = 100;                   // amplitude of pulse waveform
volatile boolean firstBeat = true;        // seed rate array so we startup with reasonable BPM
volatile boolean secondBeat = true;       // seed rate array so we startup with reasonable BPM

// graphics
const uint8_t boot_logo_bits[] PROGMEM = { // wolf moon
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x1f, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x1f, 0x20, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x1f, 0x38, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x80, 0xff, 0x3f, 0x7e, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x3f, 0x3f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x40, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x0f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00
};

const uint8_t low_battery_bits[] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xfe, 0x00, 0x07, 0x78, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x80, 0xff, 0x03, 0x0f, 0x78, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xc0, 0x87, 0x07, 0x0f, 0x78, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x01, 0x0f, 0x0e, 0x78, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xf0, 0x00, 0x1e, 0x0e, 0xfc, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x70, 0x00, 0x1c, 0x1e, 0xcc, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x78, 0x00, 0x3c, 0x1c, 0xcc, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x38, 0x00, 0x38, 0x1c, 0xcc, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x38, 0x00, 0xf8, 0x1d, 0xce, 0xe1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x38, 0x00, 0xf8, 0x39, 0x86, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x38, 0x00, 0xd8, 0x3b, 0x86, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x38, 0x00, 0xc8, 0x37, 0x86, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x38, 0x00, 0xc8, 0x67, 0x87, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x78, 0x00, 0xec, 0x67, 0x03, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x70, 0x00, 0xe4, 0x6f, 0x03, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xf0, 0x00, 0xe2, 0xef, 0x03, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x01, 0xf7, 0xef, 0x03, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xc0, 0xc3, 0xfb, 0xef, 0x01, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x83, 0xff, 0xfc, 0xff, 0x21, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x03, 0xfe, 0xfe, 0xff, 0x39, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x3f, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x9f, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x7f, 0xff, 0x1f, 0x3f, 0x00, 0xf8, 0xff, 0xff, 0xf8, 0xff, 0xe0, 0x7f, 0x78, 0x00, 0x0f, 0xe0, 0x7f, 0xfe, 0x0f, 0x3e, 0x00, 0xfe, 0xff, 0xff, 0xf8, 0xff, 0xe0, 0xff, 0xf0, 0x80, 0x07, 0xe0, 0x60, 0xfe, 0x0f, 0xfe, 0x1f, 0x01, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0xe0, 0xf1, 0x80, 0x07, 0xe0, 0x40, 0xfc, 0x0f, 0xfc, 0x1f, 0x03, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0xc0, 0xe3, 0xc1, 0x03, 0xe0, 0x60, 0xfc, 0x07, 0xfc, 0x1f, 0x03, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0x80, 0xc3, 0xe3, 0x01, 0xe0, 0x60, 0xfc, 0x47, 0xfc, 0x1f, 0x01, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0x80, 0x83, 0xe7, 0x00, 0xe0, 0x7e, 0xfc, 0x43, 0xf8, 0x1f, 0x01, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0x80, 0x83, 0xf7, 0x00, 0x60, 0x1e, 0xfe, 0xe3, 0xf8, 0x9f, 0x00, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0x80, 0x03, 0x7f, 0x00, 0x20, 0x80, 0xff, 0xe3, 0xf8, 0x1f, 0x01, 0xc0, 0x01, 0xf8, 0x7f, 0xe0, 0xc0, 0x03, 0x7e, 0x00, 0x20, 0x00, 0xff, 0xf1, 0xf1, 0x1f, 0x01, 0xc0, 0x01, 0xf8, 0x7f, 0xe0, 0xe0, 0x01, 0x3e, 0x00, 0x00, 0x3f, 0xfc, 0xf1, 0xf1, 0x9f, 0x01, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0xff, 0x00, 0x1c, 0x00, 0x00, 0x7f, 0xfc, 0xf0, 0xe1, 0x1f, 0x00, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0x7f, 0x00, 0x1c, 0x00, 0xe0, 0xff, 0xf8, 0x00, 0xe0, 0x1f, 0x00, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0xf0, 0x01, 0x1c, 0x00, 0xe0, 0xff, 0xf8, 0x00, 0xe0, 0x1f, 0x01, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0xe0, 0x01, 0x1c, 0x00, 0xe0, 0xfe, 0x78, 0xfc, 0xc7, 0x1f, 0x00, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0xc0, 0x03, 0x1c, 0x00, 0xe0, 0xfc, 0x78, 0xfc, 0xc7, 0x1f, 0x00, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0x80, 0x07, 0x1c, 0x00, 0xe0, 0x7c, 0x38, 0xfc, 0x87, 0x9f, 0x00, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0x80, 0x07, 0x1c, 0x00, 0xe0, 0x3e, 0x3c, 0xfe, 0x8f, 0x9f, 0x01, 0xc0, 0x01, 0x38, 0x00, 0xe0, 0x00, 0x0f, 0x1c, 0x00, 0xe0, 0x00, 0x3e, 0xfe, 0x8f, 0x1f, 0x00, 0xc0, 0x01, 0xf8, 0xff, 0xe0, 0x00, 0x0f, 0x1c, 0x00, 0xe0, 0x80, 0x1f, 0xff, 0x1f, 0x1f, 0x00, 0xc0, 0x01, 0xf8, 0xff, 0xe0, 0x00, 0x1e, 0x1c, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// https://bluepichu.wordpress.com/2012/07/16/fast-pwm-with-arduino-fast/
void interruptTimer1Setup()
{
	TCCR1A = 0; // set entire TCCR1A register to 0
	TCCR1B = 0; // set entire TCCR1B register to 0 
	
	TCCR1A |= (1 << WGM10); // enable mode 15 Fast PWM (TOP is OCR1A)
	TCCR1A |= (1 << WGM11);
	TCCR1B |= (1 << WGM12);
	TCCR1B |= (1 << WGM13);
	
	TCCR1B |= (1 << CS10); // Set CS10 bit so timer runs at clock speed (no prescaling)

	TCCR1A |= (1 << COM1A0); // Toggle OC1A (digital pin 9) on Compare Match. doc8161.pdf p135 Table 15.2
	
	OCR1A = 65534 * MW / ((currentmv * currentmv) / COILmOHMS); // set TOP
	//OCR1A = 30000;
}

// timer 2
// described here http://pulsesensor.com/pages/pulse-sensor-amped-arduino-v1dot1
// look at http://electronics.stackexchange.com/a/26387/66192 for even more information
void interruptTimer2Setup() // Initializes Timer2 to throw an interrupt every 2mS.
{
	TCCR2A = 0x02;     // DISABLE PWM ON DIGITAL PINS 3 AND 11, AND GO INTO CTC MODE
	TCCR2B = 0x06;     // DON'T FORCE COMPARE, 256 PRESCALER
	OCR2A = 0X7C;      // SET THE TOP OF THE COUNT TO 124 FOR 500Hz SAMPLE RATE
	TIMSK2 = 0x02;     // ENABLE INTERRUPT ON MATCH BETWEEN TIMER2 AND OCR2A
	//sei(); // interrupts are enabled in setup()
}

// tidied up from http://pulsesensor.com/pages/pulse-sensor-amped-arduino-v1dot1\
// Joel Murphy & Yury Gitman  Fall 2012
// https://github.com/WorldFamousElectronics/PulseSensor_Amped_Arduino/blob/master/PulseSensorAmped_Arduino_1dot2/Interrupt.ino (MIT License)
ISR(TIMER2_COMPA_vect) // triggered when Timer2 counts to 124
{
	cli();                                     // disable interrupts while we do this
	Signal = analogRead(PIN_HR_MONITOR);       // read Pulse Sensor 
	sampleCounter += 2;                        // keep track of time in ms
	int N = sampleCounter - lastBeatTime;      // monitor the time since the last beat to avoid noise

	// find the peak and trough of the pulse wave
	if (Signal < thresh && N > (IBI/5)*3)      // avoid dichrotic noise by waiting 3/5 of last IBI
		if (Signal < trough)
			trough = Signal;                     // keep track of lowest point in pulse wave                      
	
	if (Signal > thresh && Signal > peak)      // thresh condition helps avoid noise
		peak = Signal;                          // keep track of highest point in pulse wave

	// NOW IT'S TIME TO LOOK FOR THE HEART BEAT
	// signal surges up in value every time there is a pulse
	if (N > 250) {                             // avoid high frequency noise
		if ( (Signal > thresh) && (Pulse == false) && (N > (IBI/5)*3) ) {        
			Pulse = true;                        // set the Pulse flag when we think there is a pulse
			digitalWrite(PIN_BOARDLED,HIGH);     // turn on pin 13 LED
			IBI = sampleCounter - lastBeatTime;  // measure time between beats in mS
			lastBeatTime = sampleCounter;        // keep track of time for next pulse
					
			if(firstBeat) {                      // if it's the first time we found a beat, if firstBeat == TRUE
				firstBeat = false;                // clear firstBeat flag
				return;                           // IBI value is unreliable so discard it
			}   
			if(secondBeat) {                     // if this is the second beat, if secondBeat == TRUE
				secondBeat = false;               // clear secondBeat flag
				for(int i=0; i<=9; i++)           // seed the running total to get a realisitic BPM at startup
					rate[i] = IBI;                      
			}
          
			// keep a running total of the last 10 IBI values
			word runningTotal = 0;               // clear the runningTotal variable    

			for(int i=0; i<=8; i++){             // shift data in the rate array
				rate[i] = rate[i+1];              // drop the oldest IBI value
				runningTotal += rate[i];          // add up the 9 oldest IBI values
			}

			rate[9] = IBI;                       // add the latest IBI to the rate array
			runningTotal += rate[9];             // add the latest IBI to runningTotal
			runningTotal /= 10;                  // average the last 10 IBI values
			heart_BPM = 60000/runningTotal;      // how many beats can fit into a minute? that's BPM!
			QS = true;                           // set Quantified Self flag - note not cleared in this ISR
		}
	}

	if (Signal < thresh && Pulse == true) {    // when the values are going down, the beat is over
		digitalWrite(PIN_BOARDLED,LOW);         // turn off pin 13 LED
		Pulse = false;                          // reset the Pulse flag so we can do it again
		amp = peak - trough;                    // get amplitude of the pulse wave
		thresh = amp/2 + trough;                // set thresh at 50% of the amplitude
		peak = thresh;                          // reset these for next time
		trough = thresh;
	}
  
	if (N > 2500) {                            // reset if 2.5 seconds go by without a beat
		heart_BPM = 0;                          // heart rate back to zero
		thresh = 512;                           // set thresh default
		peak = 512;                             // set P default
		trough = 512;                           // set T default
		lastBeatTime = sampleCounter;           // bring the lastBeatTime up to date
		firstBeat = true;                       // set these to avoid noise
		secondBeat = true;                      // when we get the heartbeat back
	}
  
	sei();                                     // enable interrupts
}

bool debouncecheck()
{
	// go through button states here?
	if (millis() - debouncelock > DEBOUNCEWAITMS) { // handles rollover at 4294967296
		debouncelock = millis(); // start a new debounce timer
		return true;
	}
	return false; // debounce still in effect
}

uint16_t getmV() // this should always return a value between about 7500 and 7100, so there's no need to size it
{
	return 7300; // FIXME: hack for debugging
	//return (analogRead(PIN_READVOLTAGE)*VDIV)/10; // returns about 7400mV if working .. instruct to charge if <7100
	return analogRead(PIN_READVOLTAGE) * VDIV / 10; // compensate for uint8_t use
}

uint8_t batteryEstimate()
{
	if (currentmv < MINmV) // too small - makes the math bad
		return 0;
	if (currentmv > MAXmV) // more is merrier
		return 100;
	uint8_t value = ((currentmv-MINmV)*100)/(MAXmV-MINmV); // truncate as integer
	return value;
}

void updateline1()
{
	uint16_t y = MW;
	uint16_t x = y / 1000;
	y -= x * 1000;
	if (MW > MAXWATTAGE)
		(void) sprintf(line1,"DANGR %2d.%dW",x,y/100); // not used in this case
	else
		(void) sprintf(line1,"Power %2d.%dW",x,y/100);
}

void updateline2()
{
	if (heart_BPM > MINHR)
		(void) sprintf(line2," %3d bpm",heart_BPM); // cool to add a heart \u2665
	else
		(void) sprintf(line2," --- bpm");
}

void updateline3()
{
	if (currentmv < MINmV) { // charge the damn batteries
		(void) sprintf(line3,"Charge Me!");
		return;
	}
	if (currentmv > CHARGEmV) {
		(void) sprintf(line3,"Charging");
		return;
	}
	uint16_t y = currentmv;
	uint16_t x = y / 1000;
	y -= x * 1000;
	(void) sprintf(line3,"%d.%2dV %3d%%",x,y/10,batteryEstimate()); // y will always be between 100 and 400
}

void updatescreen()
{
	u8g.firstPage();
	do {
		draw();
	} while(u8g.nextPage());
}

void draw() // graphic commands (will redraw the complete screen)
{
	u8g.setFont(FONT); // may not be necessary to put in loop

	// regular orientation
	u8g.drawStr(LEFTEDGE, LINEFIRST + LINEHEIGHT * 1, line1); // output wattage
	u8g.drawStr(LEFTEDGE, LINEFIRST + LINEHEIGHT * 2, line2); // heart rate (if active)
	u8g.drawStr(LEFTEDGE, LINEFIRST + LINEHEIGHT * 3, line3); // battery state*/
	
	// 180 flip
	/*u8g.drawStr180(RIGHTEDGE, -LINEFIRST + LINEHEIGHT * 3, line1); // output wattage
	u8g.drawStr180(RIGHTEDGE, -LINEFIRST + LINEHEIGHT * 2, line2); // heart rate (if active)
	u8g.drawStr180(RIGHTEDGE, -LINEFIRST + LINEHEIGHT * 1, line3); // battery state*/
	
	u8g.drawFrame(0,0,SCREENWIDTH,SCREENHEIGHT); // frame around screen
}

void incrementWattage()
{
	if(debouncecheck) {
		MW_former = MW;
		MW += 500;
	}
	if (MW > MAXWATTAGE)
		MW = MAXWATTAGE;
}

void decrementWattage()
{
	if(debouncecheck) {
		MW_former = MW;
		MW -= 500;
	}
	if (MW < MINWATTAGE)
		MW = MINWATTAGE;
}

// the setup routine runs once after device boot (gains power or is reset)
void setup()
{
	cli(); // disable interrupts during setup
	
	// get values from EEPROM
	
	// make sure the watage is reasonable
	if ((MW > MAXWATTAGE) or (MW < MINWATTAGE))
		MW = (MINWATTAGE + MAXWATTAGE) / 2;
	
	// output pins
	pinMode(PIN_BOARDLED,OUTPUT);
	pinMode(PIN_COIL_PWM,OUTPUT);
	// input pins
	pinMode(PIN_READVOLTAGE,INPUT);
	pinMode(PIN_PUSHBUTTON,INPUT_PULLUP); // INPUT_PULLUP enables the pull-up resistor on these to protect them
	pinMode(PIN_WATTSINC,INPUT_PULLUP);
	pinMode(PIN_WATTSDEC,INPUT_PULLUP);
	pinMode(PIN_HR_MONITOR,INPUT);
	// prepare pins
	digitalWrite(PIN_BOARDLED,LOW);     // disable onboard LED
	analogWrite(PIN_COIL_PWM,0);        // ensure coil pin is not providing output
	digitalWrite(PIN_READVOLTAGE,HIGH); // prepare input pins for test LOW to GND with internal pullup resistor

	// initialize interrupts
	interruptTimer2Setup(); // interrupt timer every 2ms for heart rate monitor

	currentmv = getmV(); // update current millivolts for initial display image
	
	// display boot logo
	u8g.firstPage();
	do {
		if (currentmv > MINmV) // test if low battery
			u8g.drawXBMP(0,0,SCREENWIDTH,SCREENHEIGHT,boot_logo_bits);
		else
			u8g.drawXBMP(0,0,SCREENWIDTH,SCREENHEIGHT,low_battery_bits);
	} while(u8g.nextPage());
	
	sei(); // enable interrupts
	delay(2000); // wait 2s before continuing to guarantee display .. interrupts must be enabled

	// get values and draw initial screen
	updateline1();
	updateline2();
	updateline3();
	updatescreen();

	//Timer1.initialize(1000); // start timer1 at 1ms
}

// aduino loop forever
void loop()
{
	currentmv = getmV(); // update the current voltage to be read by timer interrupt

	// update wattages
	if (digitalRead(PIN_WATTSDEC) == HIGH) decrementWattage(); // internal timer handles debounce
	if (digitalRead(PIN_WATTSINC) == HIGH) incrementWattage();
	
	// update screen
	updateline1();
	updateline2();
	updateline3();
	updatescreen(); // power use should be negligible

	if (digitalRead(PIN_PUSHBUTTON) == HIGH and debouncecheck() and !pwmlock) {
		pwmlock = true; // prevent timer from continually being re-set until released
		interruptTimer1Setup(); // enable timer1
		digitalWrite(PIN_BOARDLED,HIGH); // DEBUG: turn on board LED
	}
	if (digitalRead(PIN_PUSHBUTTON) == LOW and debouncecheck()) {
		TCCR1A = 0; // disable/wipe timer 1
		TCCR1B = 0;
		//analogWrite(PIN_COIL_PWM,0); // ensure PWM coil isn't still running
		digitalWrite(PIN_COIL_PWM,LOW);
		digitalWrite(PIN_BOARDLED,LOW); // DEBUG: turn off board LED
		pwmlock = false; // allow button to be pressed again
	}
}
